# 版本管理及持续集成设计

## 工具选型

### 版本管理工具

系统采用微服务架构，通过`gitlab`对版本进行管理。整个系统是一个独立的版本仓库。每一个组件是一个单独的文件夹。每一个组件都可以独立编译。版本仓库仅有1个长期分支：主线分支`master`。

### 持续集成工具

持续集成过程由`Jenkins`进行管理。持续集成工具负责监控代码提交，对提交的代码进行编译、构建、测试、打包，最终产生一个docker image，并上传至内部的docker仓库。

持续集成工具负责代码从提交到发布的整个过程。是整个开发流程的核心。

### docker registry

系统的最终发布物为一系列docker images。系统使用的所有的docker images（包括基础设施的image）都由公司内部的docker registry进行管理。docker image的tag将被用于发布版本管理。

### 部署工具

部署工具负责选择适当的发布版本，将其部署至客户服务器。同时记录每一次部署行为。部署工具及部署方法待定。

## 系统开发流程设计

### 开发过程

为了避免分支污染及有效控制代码质量，各开发人员均fork一份代码库自行管理。每一个新功能或修改创建一个分支。待开发完成后，向主版本提交`Merge Request`。代码审核人员对每一个`Merge Request`进行审核，审核通过可以进入主线分支。审核未通过的可以进一步修改，直至通过。如果某个Request是不必要的，也可以暂缓合并或者直接撤回。开发人员提交`Merge Request`时，必须关联对应的`issue id`。一个`Merge Request`解决一个issue。一旦合并进入主线，持续集成工具将自动集成此次提交。如果集成失败则需要开发人员进行修改，直至集成成功。集成成功后，原分支将被关闭或删除。避免污染时间线。

所有的开发都必须从建立`issue`开始。issue的建立人可以是需求、测试、开发者或各类流程管理工具（自动化创建issue）。issue的内容可以是需求、bug或改进。issue由issue管理工具进行管理，这里不再赘述。issue管理工具必须能与gitlab及持续集成工具整合。简单起见，初期可以直接使用gitlab自带的issue管理功能。

另外要注意的一点是，由于引入了每日构建，每日的提交必须完整。不允许将不完整的功能提交至主线。不完整的提交可以暂存在私有仓库或分支中，待开发完成一并提交Merge Request。在提交Merge Request之前，可以考虑使用git的`rebase`功能对提交进行整理。

### 持续集成过程

目前定义了四种不同的持续集成过程。下面分别详述。

#### 提交编译过程

当版本仓库主线有新的提交时，将触发提交编译过程。过程如下：

1. 构建名为当前构建号`BUILD_NUMBER`。
2. 从版本仓库主线分支checkout完整的代码。然后判断组件子目录中哪些组件发生了变化，变化的组件将会被编译。
3. 将提交日志作为构建时的changelog。
4. 将字符串“B`BUILD_NUMBER`”作为版本号写入特定的Java代码，该信息将在运行时写入运行日志。如果在上一步发现有多个组件需要编译，对于该次构建，这些组件的`BUILD_NUMBER`是相同的
5. 编译每一个需要构建的组件。不同组件间的编译可以是并发的。
6. 编译完成后，对每一个组件进行单元测试。不同组件间的测试可以是并发的。
7. 检查编译结果、单元测试结果和单元测试覆盖率。有任一项没有达到要求，则此次构建失败。
8. 如果构建成功，则将构建结果打包成docker image。其tag为`BUILD_NUMBER`
9. 将打包好的docker image上传至docker registry。
10. 如果构建失败，将构建结果通知相关开发人员。

提交编译过程主要是通过编译、单元测试及测试覆盖率来确保每次提交的正确性。另外，其构建结果也可以在特殊情况下作为测试的备选结果使用。

#### 每日构建过程

每日到达指定时间（一般是凌晨1:00），将触发每日构建过程。过程如下：

1. 构建名为“`BUILD_NUMBER`-daily”。
2. 从版本仓库主线分支checkout完整的代码。然后判断组件子目录中哪些组件在上一日1:00 ~ 当日1:00之间发生了变化，变化的组件将会被编译。
3. 收集每一个需要构建的组件从上一日1:00 ~ 当日1:00之间的提交日志，并汇总作为构建时的changelog。
4. 将字符串“D`BUILD_NUMBER`”写入特定的Java代码，该信息将在运行时写入运行日志。如果在上一步发现有多个组件需要编译，对于该次构建，这些组件的`BUILD_NUMBER`是相同的
5. 编译每一个需要构建的组件。不同组件间的编译可以是并发的。
6. 编译完成后，对每一个组件进行单元测试。不同组件间的测试可以是并发的。
7. 检查编译结果、单元测试结果和单元测试覆盖率。有任一项没有达到要求，则此次构建失败。
8. 对编译结果进一步执行组件测试、接口测试。
9. 检查上述测试结果。有任一项没有达到要求，则此次构建失败。
10. 如果构建成功，则将构建结果打包成docker image。其tag为`BUILD_NUMBER`-daily。
11. 如果构建失败，将构建结果通知相关开发人员。

每日构建的目的主要是为测试人员提供测试用的基础docker包。每日构建的结果已经通过了基本的自动化测试，可以直接用于集成测试。

#### 候选标记过程

在测试完指定的构建版本并确认通过后，测试人员手工触发此过程。过程如下：

1. 测试人员选择或输入可以进入候选的构建版本。一般来说，这个版本是每日构建的版本，即“`BUILD_NUMBER`-daily”；但也可以是提交编译的版本，即“`BUILD_NUMBER`”。
2. 对docker registry上指定版本的image增加tag：`BUILD_NUMBER`-rc。注意，这里的`BUILD_NUMBER`是每日构建过程或提交编译过程确定的，**与本次构建的构建号无关**。
3. 如果选择的构建版本涉及多个组件，则多个组件一起被标记为rc。
4. 通知相关发布人员。

候选标记过程的目的是标记指定的版本测试通过，可以用于发布。

#### 发布标记过程

发布人员手工触发此过程。过程如下：

1. 发布人员选择或输入被标记为候选的构建版本。一般来说，这个版本是最新的候选版本。但也可以是之前的候选版本。
2. 对docker registry上指定候选版本的image增加tag：`BUILD_NUMBER`-release。注意，这里的`BUILD_NUMBER`是每日构建过程或提交编译过程确定的，**与本次构建的构建号无关**。
3. 如果选择的构建版本涉及多个组件，则多个组件一起被标记为rc。
4. 通知相关实施人员。

发布标记过程的目的是标记指定版本可以发布。

### 发布过程

系统发布采用持续发布模式。代码审核人员将开发提交合并进入主线分支后，将触发提交编译过程。如果提交编译过程不通过，则开发人员必须在每日构建过程之前保证提交编译过程通过。确保每日构建过程执行时至少代码是可以正常编译和通过单元测试的。必要时可以退回修改重新提交。

测试人员在一轮测试完成后，进入持续集成工具查看每日构建的情况，根据实际需要选择一个每日构建结果进行新一轮的测试。如果每日构建结果无法测试，测试人员也可以酌情考虑使用某一个提交编译结果进行测试。

如果测试通过，测试人员可以将此版本标记为候选发布。

发布人员检查所有候选发布版本，从中选择一个作为发布版本。

实施人员通过部署工具将某一个发布版本发布至客户环境。（具体方法及工具待定）

如果发布版本出现bug或新需求，则纳入下一轮开发计划。

一次发布只解决一个或少数几个问题。发布的周期应该是快且频繁。

原则上发布应该是始终向前进。如果某次发布出现bug则进入下一轮发布阶段，在此阶段中修复bug。

但如果确实发现bug且无法在短时间内修复，可以考虑退回上一个发布，并抛弃当前发布版本。版本库恢复至上一次发布对应的提交，并做一次新的提交以作为新的起点。